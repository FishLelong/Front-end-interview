/* src/pages/LPStaking.svelte generated by Svelte v3.29.0 */
import {
	SvelteComponent,
	append,
	attr,
	component_subscribe,
	destroy_each,
	detach,
	element,
	empty,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	set_input_value,
	set_style,
	space,
	text
} from "../../web_modules/svelte/internal.js";

import { ethers } from "../../web_modules/ethers.js";
import { onMount } from "../../web_modules/svelte.js";
import BigNumber from "../../web_modules/bignumberjs.js";
import { validateIsAddress } from "../../web_modules/@pie-dao/utils.js";
import { _ } from "../../web_modules/svelte-i18n.js";
import images from "../config/images.json.proxy.js";
import { currentRoute } from "../stores/routes.js";
import filter from "../../web_modules/lodash/filter.js";
import isNaN from "../../web_modules/lodash/isNaN.js";
import recipeUnipool from "../config/unipoolABI.json.proxy.js";
import BALANCER_POOL_ABI from "../config/balancerPoolABI.json.proxy.js";
import geyserABI from "../config/geyser.json.proxy.js";
import { get } from "../../web_modules/svelte/store.js";
import displayNotification from "../notifications.js";
import { piesMarketDataStore } from "../stores/coingecko.js";
import { farming } from "../stores/eth/writables.js";

import {
	amountFormatter,
	fetchPieTokens,
	fetchPooledTokens,
	maxAmount,
	getTokenImage,
	fetchEthBalance,
	fetchCalcToPie,
	toFixed,
	calculateAPRBalancer,
	calculateAPRUniswap,
	formatFiat,
	subscribeToBalance,
	subscribeToAllowance,
	subscribeToStaking,
	subscribeToStakingEarnings,
	subscribeToStakingEarningsGeyser
} from "../components/helpers.js";

import {
	allowances,
	functionKey,
	approveMax,
	balanceKey,
	balances,
	connectWeb3,
	contract,
	eth,
	pools,
	bumpLifecycle,
	subject
} from "../stores/eth.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[42] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[42] = list[i];
	return child_ctx;
}

// (705:8) {:else}
function create_else_block_7(ctx) {
	let div0;
	let button0;
	let t1;
	let t2;
	let div21;
	let div10;
	let img0;
	let img0_src_value;
	let t3;
	let div1;
	let t4;
	let t5;
	let div2;

	let t6_value = (/*pool*/ ctx[3].KeyAddressTokenToStake
	? amountFormatter({
			amount: /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance],
			displayDecimals: 4
		})
	: 0) + "";

	let t6;
	let t7;
	let t8_value = /*pool*/ ctx[3].toStakeSymbol + "";
	let t8;
	let t9;
	let div3;
	let t11;
	let div4;
	let t12_value = /*pool*/ ctx[3].toStakeDesc + "";
	let t12;
	let t13;
	let div9;
	let div6;
	let div5;
	let t14_value = /*$_*/ ctx[9]("general.amount") + "";
	let t14;
	let t15;
	let t16;
	let div8;
	let input0;
	let t17;
	let div7;
	let button1;
	let t19;
	let t20;
	let div20;
	let img1;
	let img1_src_value;
	let t21;
	let div11;
	let t23;
	let div12;

	let t24_value = (/*pool*/ ctx[3].KeyAddressTokenToStake
	? amountFormatter({
			amount: /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyAddressTokenToStake],
			displayDecimals: 4
		})
	: 0) + "";

	let t24;
	let t25;
	let t26_value = /*pool*/ ctx[3].toStakeSymbol + "";
	let t26;
	let t27;
	let div13;
	let t29;
	let div14;
	let t30_value = /*pool*/ ctx[3].toStakeDesc + "";
	let t30;
	let t31;
	let div19;
	let div16;
	let div15;
	let t32_value = /*$_*/ ctx[9]("general.amount") + "";
	let t32;
	let t33;
	let t34;
	let div18;
	let input1;
	let t35;
	let div17;
	let button2;
	let t37;
	let t38;
	let t39;
	let t40;
	let div22;
	let t41;
	let t42;
	let br0;
	let br1;
	let t43;
	let p0;
	let t44;
	let t45_value = /*pool*/ ctx[3].platform + "";
	let t45;
	let t46;
	let t47_value = /*pool*/ ctx[3].toStakeSymbol + "";
	let t47;
	let t48;
	let a0;
	let t49;
	let a0_href_value;
	let t50;
	let p1;
	let t51;
	let strong;
	let t52_value = /*pool*/ ctx[3].weeklyRewards + "";
	let t52;
	let t53;
	let t54_value = /*pool*/ ctx[3].rewards_token + "";
	let t54;
	let t55;
	let p2;
	let t56;
	let t57_value = /*pool*/ ctx[3].containing[0].symbol + "";
	let t57;
	let t58;
	let a1;
	let t59;
	let a1_href_value;
	let t60;
	let a2;
	let t61;
	let a2_href_value;
	let t62;
	let p3;
	let mounted;
	let dispose;
	let if_block0 = /*pool*/ ctx[3].KeyAddressTokenToStake && /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance] > 0 && /*pool*/ ctx[3].contractType !== "Geyser" && create_if_block_20(ctx);
	let if_block1 = /*pool*/ ctx[3].contractType === "Geyser" && create_if_block_19(ctx);

	function select_block_type_8(ctx, dirty) {
		if (/*amountToUnstake*/ ctx[1] === 0) return create_if_block_18;
		return create_else_block_9;
	}

	let current_block_type = select_block_type_8(ctx, [-1]);
	let if_block2 = current_block_type(ctx);

	function select_block_type_9(ctx, dirty) {
		if (/*needAllowance*/ ctx[5]) return create_if_block_16;
		if (/*amountToStake*/ ctx[0] === 0) return create_if_block_17;
		return create_else_block_8;
	}

	let current_block_type_1 = select_block_type_9(ctx, [-1]);
	let if_block3 = current_block_type_1(ctx);
	let if_block4 = /*pool*/ ctx[3].contractType === "UniPool" && create_if_block_15(ctx);
	let if_block5 = /*pool*/ ctx[3].contractType === "Geyser" && create_if_block_14(ctx);
	let if_block6 = /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll] !== undefined && create_if_block_12(ctx);
	let if_block7 = /*pool*/ ctx[3].contractType === "Geyser" && create_if_block_11(ctx);

	return {
		c() {
			div0 = element("div");
			button0 = element("button");
			button0.textContent = "Go back";
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			div21 = element("div");
			div10 = element("div");
			img0 = element("img");
			t3 = space();
			div1 = element("div");
			t4 = text("UNSTAKE ");
			if (if_block1) if_block1.c();
			t5 = space();
			div2 = element("div");
			t6 = text(t6_value);
			t7 = space();
			t8 = text(t8_value);
			t9 = space();
			div3 = element("div");
			div3.textContent = "STAKED BALANCE";
			t11 = space();
			div4 = element("div");
			t12 = text(t12_value);
			t13 = space();
			div9 = element("div");
			div6 = element("div");
			div5 = element("div");
			t14 = text(t14_value);
			t15 = text(" to unstake");
			t16 = space();
			div8 = element("div");
			input0 = element("input");
			t17 = space();
			div7 = element("div");
			button1 = element("button");
			button1.textContent = "MAX";
			t19 = space();
			if_block2.c();
			t20 = space();
			div20 = element("div");
			img1 = element("img");
			t21 = space();
			div11 = element("div");
			div11.textContent = "STAKE";
			t23 = space();
			div12 = element("div");
			t24 = text(t24_value);
			t25 = space();
			t26 = text(t26_value);
			t27 = space();
			div13 = element("div");
			div13.textContent = "BALANCE";
			t29 = space();
			div14 = element("div");
			t30 = text(t30_value);
			t31 = space();
			div19 = element("div");
			div16 = element("div");
			div15 = element("div");
			t32 = text(t32_value);
			t33 = text(" to stake");
			t34 = space();
			div18 = element("div");
			input1 = element("input");
			t35 = space();
			div17 = element("div");
			button2 = element("button");
			button2.textContent = "MAX";
			t37 = space();
			if_block3.c();
			t38 = space();
			if (if_block4) if_block4.c();
			t39 = space();
			if (if_block5) if_block5.c();
			t40 = space();
			div22 = element("div");
			if (if_block6) if_block6.c();
			t41 = space();
			if (if_block7) if_block7.c();
			t42 = space();
			br0 = element("br");
			br1 = element("br");
			t43 = space();
			p0 = element("p");
			t44 = text("You can add liquidity to the ");
			t45 = text(t45_value);
			t46 = text(" pool to get ");
			t47 = text(t47_value);
			t48 = text(" tokens ");
			a0 = element("a");
			t49 = text("HERE");
			t50 = space();
			p1 = element("p");
			t51 = text("Weekly rewards for this pool are ");
			strong = element("strong");
			t52 = text(t52_value);
			t53 = space();
			t54 = text(t54_value);
			t55 = space();
			p2 = element("p");
			t56 = text("Buy ");
			t57 = text(t57_value);
			t58 = text(" on ");
			a1 = element("a");
			t59 = text("Balancer");
			t60 = text(" or ");
			a2 = element("a");
			t61 = text("mint now!");
			t62 = space();
			p3 = element("p");
			p3.innerHTML = `Buy DOUGH on <a target="_blank" href="https://balancer.exchange/#/swap/ether/0xad32A8e6220741182940c5aBF610bDE99E737b2D">Balancer</a>`;
			attr(button0, "class", "md:w-1 float-left btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
			attr(img0, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img0.src !== (img0_src_value = images.withdraw)) attr(img0, "src", img0_src_value);
			attr(img0, "alt", "PieDAO logo");
			attr(div1, "class", "title text-lg");
			attr(div2, "class", "apy");
			attr(div3, "class", "subtitle font-thin");
			attr(div4, "class", "apy text-sm");
			attr(div5, "class", "left float-left");
			attr(div6, "class", "top h-24px text-sm font-thin px-4 py-4 md:py-2");
			attr(input0, "type", "text");
			attr(input0, "class", "text-black font-thin text-base w-60pc md:w-75pc md:text-lg");
			attr(button1, "class", "text-black py-2px px-4px");
			attr(div7, "class", "text-black asset-btn float-right h-32px bg-grey-243 rounded-32px px-2px flex align-middle justify-center items-center pointer mt-0");
			attr(div8, "class", "bottom px-4 py-4 md:py-2");
			attr(div9, "class", "w-80 input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
			attr(div10, "class", "farming-card flex flex-col justify-center align-center items-center mx-1 my-4  border border-gray border-opacity-50 border-solid rounded-sm py-2");
			attr(img1, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img1.src !== (img1_src_value = images.stake)) attr(img1, "src", img1_src_value);
			attr(img1, "alt", "PieDAO logo");
			attr(div11, "class", "title text-lg");
			attr(div12, "class", "apy");
			attr(div13, "class", "subtitle font-thin");
			attr(div14, "class", "apy text-sm");
			attr(div15, "class", "text-black left black float-left");
			attr(div16, "class", "top h-24px text-sm font-thin px-4 py-4 md:py-2");
			attr(input1, "type", "text");
			attr(input1, "class", "text-black font-thin text-base w-60pc md:w-75pc md:text-lg");
			attr(button2, "class", "text-black py-2px px-4px");
			attr(div17, "class", "text-black asset-btn float-right h-32px bg-grey-243 rounded-32px px-2px flex align-middle justify-center items-center pointer mt-0");
			attr(div18, "class", "bottom px-4 py-4 md:py-2");
			attr(div19, "class", "w-80 input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
			attr(div20, "class", "farming-card highlight-box flex flex-col justify-center align-center items-center mx-1 my-4  border border-grey border-opacity-50 border-solid rounded-sm py-2");
			attr(div21, "class", "flex flex-col w-full justify-around md:flex-row");
			attr(a0, "href", a0_href_value = /*pool*/ ctx[3].poolLink);
			attr(a1, "target", "_blank");
			attr(a1, "href", a1_href_value = "https://balancer.exchange/#/swap/ether/" + /*pool*/ ctx[3].containing[0].address);
			attr(a2, "href", a2_href_value = "#/pools/" + /*pool*/ ctx[3].containing[0].address);
			attr(div22, "class", "info-box");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, button0);
			append(div0, t1);
			if (if_block0) if_block0.m(div0, null);
			insert(target, t2, anchor);
			insert(target, div21, anchor);
			append(div21, div10);
			append(div10, img0);
			append(div10, t3);
			append(div10, div1);
			append(div1, t4);
			if (if_block1) if_block1.m(div1, null);
			append(div10, t5);
			append(div10, div2);
			append(div2, t6);
			append(div2, t7);
			append(div2, t8);
			append(div10, t9);
			append(div10, div3);
			append(div10, t11);
			append(div10, div4);
			append(div4, t12);
			append(div10, t13);
			append(div10, div9);
			append(div9, div6);
			append(div6, div5);
			append(div5, t14);
			append(div5, t15);
			append(div9, t16);
			append(div9, div8);
			append(div8, input0);
			set_input_value(input0, /*amountToUnstake*/ ctx[1]);
			append(div8, t17);
			append(div8, div7);
			append(div7, button1);
			append(div10, t19);
			if_block2.m(div10, null);
			append(div21, t20);
			append(div21, div20);
			append(div20, img1);
			append(div20, t21);
			append(div20, div11);
			append(div20, t23);
			append(div20, div12);
			append(div12, t24);
			append(div12, t25);
			append(div12, t26);
			append(div20, t27);
			append(div20, div13);
			append(div20, t29);
			append(div20, div14);
			append(div14, t30);
			append(div20, t31);
			append(div20, div19);
			append(div19, div16);
			append(div16, div15);
			append(div15, t32);
			append(div15, t33);
			append(div19, t34);
			append(div19, div18);
			append(div18, input1);
			set_input_value(input1, /*amountToStake*/ ctx[0]);
			append(div18, t35);
			append(div18, div17);
			append(div17, button2);
			append(div20, t37);
			if_block3.m(div20, null);
			append(div21, t38);
			if (if_block4) if_block4.m(div21, null);
			append(div21, t39);
			if (if_block5) if_block5.m(div21, null);
			insert(target, t40, anchor);
			insert(target, div22, anchor);
			if (if_block6) if_block6.m(div22, null);
			append(div22, t41);
			if (if_block7) if_block7.m(div22, null);
			append(div22, t42);
			append(div22, br0);
			append(div22, br1);
			append(div22, t43);
			append(div22, p0);
			append(p0, t44);
			append(p0, t45);
			append(p0, t46);
			append(p0, t47);
			append(p0, t48);
			append(p0, a0);
			append(a0, t49);
			append(div22, t50);
			append(div22, p1);
			append(p1, t51);
			append(p1, strong);
			append(strong, t52);
			append(strong, t53);
			append(strong, t54);
			append(div22, t55);
			append(div22, p2);
			append(p2, t56);
			append(p2, t57);
			append(p2, t58);
			append(p2, a1);
			append(a1, t59);
			append(p2, t60);
			append(p2, a2);
			append(a2, t61);
			append(div22, t62);
			append(div22, p3);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*click_handler_3*/ ctx[18]),
					listen(input0, "input", /*input0_input_handler*/ ctx[20]),
					listen(button1, "click", /*click_handler_5*/ ctx[21]),
					listen(input1, "input", /*input1_input_handler*/ ctx[23]),
					listen(button2, "click", /*click_handler_7*/ ctx[24])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*pool*/ ctx[3].KeyAddressTokenToStake && /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance] > 0 && /*pool*/ ctx[3].contractType !== "Geyser") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_20(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*pool*/ ctx[3].contractType === "Geyser") {
				if (if_block1) {
					
				} else {
					if_block1 = create_if_block_19(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*pool, $balances*/ 24 && t6_value !== (t6_value = (/*pool*/ ctx[3].KeyAddressTokenToStake
			? amountFormatter({
					amount: /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance],
					displayDecimals: 4
				})
			: 0) + "")) set_data(t6, t6_value);

			if (dirty[0] & /*pool*/ 8 && t8_value !== (t8_value = /*pool*/ ctx[3].toStakeSymbol + "")) set_data(t8, t8_value);
			if (dirty[0] & /*pool*/ 8 && t12_value !== (t12_value = /*pool*/ ctx[3].toStakeDesc + "")) set_data(t12, t12_value);
			if (dirty[0] & /*$_*/ 512 && t14_value !== (t14_value = /*$_*/ ctx[9]("general.amount") + "")) set_data(t14, t14_value);

			if (dirty[0] & /*amountToUnstake*/ 2 && input0.value !== /*amountToUnstake*/ ctx[1]) {
				set_input_value(input0, /*amountToUnstake*/ ctx[1]);
			}

			if (current_block_type === (current_block_type = select_block_type_8(ctx, dirty)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if_block2.d(1);
				if_block2 = current_block_type(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(div10, null);
				}
			}

			if (dirty[0] & /*pool, $balances*/ 24 && t24_value !== (t24_value = (/*pool*/ ctx[3].KeyAddressTokenToStake
			? amountFormatter({
					amount: /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyAddressTokenToStake],
					displayDecimals: 4
				})
			: 0) + "")) set_data(t24, t24_value);

			if (dirty[0] & /*pool*/ 8 && t26_value !== (t26_value = /*pool*/ ctx[3].toStakeSymbol + "")) set_data(t26, t26_value);
			if (dirty[0] & /*pool*/ 8 && t30_value !== (t30_value = /*pool*/ ctx[3].toStakeDesc + "")) set_data(t30, t30_value);
			if (dirty[0] & /*$_*/ 512 && t32_value !== (t32_value = /*$_*/ ctx[9]("general.amount") + "")) set_data(t32, t32_value);

			if (dirty[0] & /*amountToStake*/ 1 && input1.value !== /*amountToStake*/ ctx[0]) {
				set_input_value(input1, /*amountToStake*/ ctx[0]);
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_9(ctx, dirty)) && if_block3) {
				if_block3.p(ctx, dirty);
			} else {
				if_block3.d(1);
				if_block3 = current_block_type_1(ctx);

				if (if_block3) {
					if_block3.c();
					if_block3.m(div20, null);
				}
			}

			if (/*pool*/ ctx[3].contractType === "UniPool") {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_15(ctx);
					if_block4.c();
					if_block4.m(div21, t39);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (/*pool*/ ctx[3].contractType === "Geyser") {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_14(ctx);
					if_block5.c();
					if_block5.m(div21, null);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll] !== undefined) {
				if (if_block6) {
					if_block6.p(ctx, dirty);
				} else {
					if_block6 = create_if_block_12(ctx);
					if_block6.c();
					if_block6.m(div22, t41);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (/*pool*/ ctx[3].contractType === "Geyser") {
				if (if_block7) {
					if_block7.p(ctx, dirty);
				} else {
					if_block7 = create_if_block_11(ctx);
					if_block7.c();
					if_block7.m(div22, t42);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (dirty[0] & /*pool*/ 8 && t45_value !== (t45_value = /*pool*/ ctx[3].platform + "")) set_data(t45, t45_value);
			if (dirty[0] & /*pool*/ 8 && t47_value !== (t47_value = /*pool*/ ctx[3].toStakeSymbol + "")) set_data(t47, t47_value);

			if (dirty[0] & /*pool*/ 8 && a0_href_value !== (a0_href_value = /*pool*/ ctx[3].poolLink)) {
				attr(a0, "href", a0_href_value);
			}

			if (dirty[0] & /*pool*/ 8 && t52_value !== (t52_value = /*pool*/ ctx[3].weeklyRewards + "")) set_data(t52, t52_value);
			if (dirty[0] & /*pool*/ 8 && t54_value !== (t54_value = /*pool*/ ctx[3].rewards_token + "")) set_data(t54, t54_value);
			if (dirty[0] & /*pool*/ 8 && t57_value !== (t57_value = /*pool*/ ctx[3].containing[0].symbol + "")) set_data(t57, t57_value);

			if (dirty[0] & /*pool*/ 8 && a1_href_value !== (a1_href_value = "https://balancer.exchange/#/swap/ether/" + /*pool*/ ctx[3].containing[0].address)) {
				attr(a1, "href", a1_href_value);
			}

			if (dirty[0] & /*pool*/ 8 && a2_href_value !== (a2_href_value = "#/pools/" + /*pool*/ ctx[3].containing[0].address)) {
				attr(a2, "href", a2_href_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (if_block0) if_block0.d();
			if (detaching) detach(t2);
			if (detaching) detach(div21);
			if (if_block1) if_block1.d();
			if_block2.d();
			if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (detaching) detach(t40);
			if (detaching) detach(div22);
			if (if_block6) if_block6.d();
			if (if_block7) if_block7.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (620:8) {#if !pool}
function create_if_block(ctx) {
	let h10;
	let t1;
	let div0;
	let t2;
	let h11;
	let t4;
	let div1;
	let each_value_1 = filter(/*incentivizedPools*/ ctx[6], { deprecated: false });
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each_value = filter(/*incentivizedPools*/ ctx[6], { deprecated: true });
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			h10 = element("h1");
			h10.textContent = "Select a pool";
			t1 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t2 = space();
			h11 = element("h1");
			h11.textContent = "⚠️ Deprecated pools";
			t4 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(h10, "class", "mt-8 mb-1 px-2 text-center text-lg md:text-xl");
			attr(div0, "class", "flex flex-col w-full justify-center md:flex-row");
			attr(h11, "class", "mt-8 mb-1 px-2 text-center text-lg md:text-xl");
			attr(div1, "class", "flex flex-col w-full justify-center md:flex-row");
		},
		m(target, anchor) {
			insert(target, h10, anchor);
			insert(target, t1, anchor);
			insert(target, div0, anchor);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			insert(target, t2, anchor);
			insert(target, h11, anchor);
			insert(target, t4, anchor);
			insert(target, div1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*pool, incentivizedPools, $farming, geyserApy*/ 456) {
				each_value_1 = filter(/*incentivizedPools*/ ctx[6], { deprecated: false });
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div0, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty[0] & /*pool, incentivizedPools*/ 72) {
				each_value = filter(/*incentivizedPools*/ ctx[6], { deprecated: true });
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) detach(h10);
			if (detaching) detach(t1);
			if (detaching) detach(div0);
			destroy_each(each_blocks_1, detaching);
			if (detaching) detach(t2);
			if (detaching) detach(h11);
			if (detaching) detach(t4);
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (708:14) {#if pool.KeyAddressTokenToStake && $balances[pool.KeyUnipoolBalance] > 0 && pool.contractType !== 'Geyser' }
function create_if_block_20(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			button.textContent = "Claim and Unstake";
			attr(button, "class", "float-right btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_4*/ ctx[19]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (717:55) {#if pool.contractType === "Geyser"}
function create_if_block_19(ctx) {
	let t;

	return {
		c() {
			t = text("and CLAIM");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (742:20) {:else}
function create_else_block_9(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			button.textContent = "Unstake";
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_6*/ ctx[22]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (740:20) {#if amountToUnstake === 0 }
function create_if_block_18(ctx) {
	let button;

	return {
		c() {
			button = element("button");
			button.textContent = "Enter an amount";
			button.disabled = true;
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4 border-white");
		},
		m(target, anchor) {
			insert(target, button, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
		}
	};
}

// (778:22) {:else}
function create_else_block_8(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			button.textContent = "Stake";
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4 border-white");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_9*/ ctx[26]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (776:22) {#if amountToStake === 0 }
function create_if_block_17(ctx) {
	let button;

	return {
		c() {
			button = element("button");
			button.textContent = "Enter an amount";
			button.disabled = true;
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4 border-white");
		},
		m(target, anchor) {
			insert(target, button, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
		}
	};
}

// (773:20) {#if needAllowance }
function create_if_block_16(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			button.textContent = "Approve";
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4 border-white");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_8*/ ctx[25]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (785:14) {#if pool.contractType === "UniPool"}
function create_if_block_15(ctx) {
	let div8;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let t2;
	let div1;
	let t3_value = /*pool*/ ctx[3].rewards_token + "";
	let t3;
	let t4;
	let t5;
	let div2;

	let t6_value = (/*pool*/ ctx[3].KeyUnipoolEarnedBalance
	? amountFormatter({
			amount: /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolEarnedBalance],
			displayDecimals: 16
		})
	: 0) + "";

	let t6;
	let t7;
	let t8_value = /*pool*/ ctx[3].rewards_token + "";
	let t8;
	let t9;
	let div7;
	let div4;
	let div3;
	let t10_value = /*$_*/ ctx[9]("general.amount") + "";
	let t10;
	let t11;
	let t12;
	let div6;
	let input;
	let t13;
	let div5;
	let button0;
	let t15;
	let button1;
	let mounted;
	let dispose;

	return {
		c() {
			div8 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			div0.textContent = "REWARDS AVAILABLE";
			t2 = space();
			div1 = element("div");
			t3 = text(t3_value);
			t4 = text(" TO CLAIM");
			t5 = space();
			div2 = element("div");
			t6 = text(t6_value);
			t7 = space();
			t8 = text(t8_value);
			t9 = space();
			div7 = element("div");
			div4 = element("div");
			div3 = element("div");
			t10 = text(t10_value);
			t11 = text(" to claim");
			t12 = space();
			div6 = element("div");
			input = element("input");
			t13 = space();
			div5 = element("div");
			button0 = element("button");
			button0.textContent = "MAX";
			t15 = space();
			button1 = element("button");
			button1.textContent = "Claim";
			attr(img, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img.src !== (img_src_value = images.claim)) attr(img, "src", img_src_value);
			attr(img, "alt", "PieDAO logo");
			attr(div0, "class", "title text-lg");
			attr(div1, "class", "subtitle font-thin");
			attr(div2, "class", "apy");
			attr(div3, "class", "left float-left");
			attr(div4, "class", "top h-24px text-sm font-thin px-4 py-4 md:py-2");
			input.disabled = true;
			attr(input, "type", "text");
			attr(input, "class", "text-black font-thin text-base w-60pc md:w-75pc md:text-lg");
			attr(button0, "class", "text-black py-2px px-4px");
			attr(div5, "class", "text-black asset-btn float-right h-32px bg-grey-243 rounded-32px px-2px flex align-middle justify-center items-center pointer mt-0");
			attr(div6, "class", "bottom px-4 py-4 md:py-2");
			attr(div7, "class", "w-80 input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
			attr(button1, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
			attr(div8, "class", "farming-card flex flex-col justify-center align-center items-center mx-1 my-4  border border-gray border-opacity-50 border-solid rounded-sm py-2");
		},
		m(target, anchor) {
			insert(target, div8, anchor);
			append(div8, img);
			append(div8, t0);
			append(div8, div0);
			append(div8, t2);
			append(div8, div1);
			append(div1, t3);
			append(div1, t4);
			append(div8, t5);
			append(div8, div2);
			append(div2, t6);
			append(div2, t7);
			append(div2, t8);
			append(div8, t9);
			append(div8, div7);
			append(div7, div4);
			append(div4, div3);
			append(div3, t10);
			append(div3, t11);
			append(div7, t12);
			append(div7, div6);
			append(div6, input);
			set_input_value(input, /*amountToClaim*/ ctx[2]);
			append(div6, t13);
			append(div6, div5);
			append(div5, button0);
			append(div8, t15);
			append(div8, button1);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[27]),
					listen(button0, "click", /*click_handler_10*/ ctx[28]),
					listen(button1, "click", /*click_handler_11*/ ctx[29])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*pool*/ 8 && t3_value !== (t3_value = /*pool*/ ctx[3].rewards_token + "")) set_data(t3, t3_value);

			if (dirty[0] & /*pool, $balances*/ 24 && t6_value !== (t6_value = (/*pool*/ ctx[3].KeyUnipoolEarnedBalance
			? amountFormatter({
					amount: /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolEarnedBalance],
					displayDecimals: 16
				})
			: 0) + "")) set_data(t6, t6_value);

			if (dirty[0] & /*pool*/ 8 && t8_value !== (t8_value = /*pool*/ ctx[3].rewards_token + "")) set_data(t8, t8_value);
			if (dirty[0] & /*$_*/ 512 && t10_value !== (t10_value = /*$_*/ ctx[9]("general.amount") + "")) set_data(t10, t10_value);

			if (dirty[0] & /*amountToClaim*/ 4 && input.value !== /*amountToClaim*/ ctx[2]) {
				set_input_value(input, /*amountToClaim*/ ctx[2]);
			}
		},
		d(detaching) {
			if (detaching) detach(div8);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (813:14) {#if pool.contractType === "Geyser"}
function create_if_block_14(ctx) {
	let div7;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let t2;
	let div1;
	let t4;
	let div2;
	let t5_value = /*geyserApy*/ ctx[7].earnedOptimistic + "";
	let t5;
	let t6;
	let t7_value = /*pool*/ ctx[3].rewards_token + "";
	let t7;
	let t8;
	let div6;
	let div4;
	let div3;
	let t9_value = /*$_*/ ctx[9]("general.amount") + "";
	let t9;
	let t10;
	let t11;
	let div5;
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			div7 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			div0.textContent = "REWARDS EARNED";
			t2 = space();
			div1 = element("div");
			div1.textContent = "Optimistic reward";
			t4 = space();
			div2 = element("div");
			t5 = text(t5_value);
			t6 = space();
			t7 = text(t7_value);
			t8 = space();
			div6 = element("div");
			div4 = element("div");
			div3 = element("div");
			t9 = text(t9_value);
			t10 = text(" accrued");
			t11 = space();
			div5 = element("div");
			input = element("input");
			attr(img, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img.src !== (img_src_value = images.claim)) attr(img, "src", img_src_value);
			attr(img, "alt", "PieDAO logo");
			attr(div0, "class", "title text-lg");
			attr(div1, "class", "subtitle font-thin");
			attr(div2, "class", "apy");
			attr(div3, "class", "left float-left");
			attr(div4, "class", "top h-24px text-sm font-thin px-4 py-4 md:py-2");
			input.disabled = true;
			attr(input, "type", "text");
			attr(input, "class", "text-black font-thin text-base w-60pc md:w-75pc md:text-lg");
			attr(div5, "class", "bottom px-4 py-4 md:py-2");
			attr(div6, "class", "w-80 input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
			attr(div7, "class", "farming-card flex flex-col justify-center align-center items-center mx-1 my-4  border border-gray border-opacity-50 border-solid rounded-sm py-2");
		},
		m(target, anchor) {
			insert(target, div7, anchor);
			append(div7, img);
			append(div7, t0);
			append(div7, div0);
			append(div7, t2);
			append(div7, div1);
			append(div7, t4);
			append(div7, div2);
			append(div2, t5);
			append(div2, t6);
			append(div2, t7);
			append(div7, t8);
			append(div7, div6);
			append(div6, div4);
			append(div4, div3);
			append(div3, t9);
			append(div3, t10);
			append(div6, t11);
			append(div6, div5);
			append(div5, input);
			set_input_value(input, /*geyserApy*/ ctx[7].earnedOptimistic);

			if (!mounted) {
				dispose = listen(input, "input", /*input_input_handler_1*/ ctx[30]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*geyserApy*/ 128 && t5_value !== (t5_value = /*geyserApy*/ ctx[7].earnedOptimistic + "")) set_data(t5, t5_value);
			if (dirty[0] & /*pool*/ 8 && t7_value !== (t7_value = /*pool*/ ctx[3].rewards_token + "")) set_data(t7, t7_value);
			if (dirty[0] & /*$_*/ 512 && t9_value !== (t9_value = /*$_*/ ctx[9]("general.amount") + "")) set_data(t9, t9_value);

			if (dirty[0] & /*geyserApy*/ 128 && input.value !== /*geyserApy*/ ctx[7].earnedOptimistic) {
				set_input_value(input, /*geyserApy*/ ctx[7].earnedOptimistic);
			}
		},
		d(detaching) {
			if (detaching) detach(div7);
			mounted = false;
			dispose();
		}
	};
}

// (833:14) {#if $farming[pool.addressUniPoll] !== undefined}
function create_if_block_12(ctx) {
	let p0;
	let t0;
	let strong0;
	let t1_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].totalBPTAmount, 4) + "";
	let t1;
	let t2;
	let t3;
	let t4;
	let p1;
	let t5;
	let strong1;
	let t6_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].totalStakedBPTAmount, 4) + "";
	let t6;
	let t7;
	let t8;
	let t9;
	let if_block_anchor;
	let if_block = /*pool*/ ctx[3].KeyAddressTokenToStake && /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance] && create_if_block_13(ctx);

	return {
		c() {
			p0 = element("p");
			t0 = text("There are total of  : ");
			strong0 = element("strong");
			t1 = text(t1_value);
			t2 = text(" BPT ");
			t3 = text(".");
			t4 = space();
			p1 = element("p");
			t5 = text("There are total   : ");
			strong1 = element("strong");
			t6 = text(t6_value);
			t7 = text(" BPT");
			t8 = text(" staked in the Staking contract.");
			t9 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			insert(target, p0, anchor);
			append(p0, t0);
			append(p0, strong0);
			append(strong0, t1);
			append(strong0, t2);
			append(p0, t3);
			insert(target, t4, anchor);
			insert(target, p1, anchor);
			append(p1, t5);
			append(p1, strong1);
			append(strong1, t6);
			append(strong1, t7);
			append(p1, t8);
			insert(target, t9, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$farming, pool*/ 264 && t1_value !== (t1_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].totalBPTAmount, 4) + "")) set_data(t1, t1_value);
			if (dirty[0] & /*$farming, pool*/ 264 && t6_value !== (t6_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].totalStakedBPTAmount, 4) + "")) set_data(t6, t6_value);

			if (/*pool*/ ctx[3].KeyAddressTokenToStake && /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_13(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(p0);
			if (detaching) detach(t4);
			if (detaching) detach(p1);
			if (detaching) detach(t9);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (836:16) {#if pool.KeyAddressTokenToStake && $balances[pool.KeyUnipoolBalance]}
function create_if_block_13(ctx) {
	let p;
	let t0;
	let strong;
	let t1_value = toFixed(/*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance] * 100 / /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].totalStakedBPTAmount, 3) + "";
	let t1;
	let t2;
	let t3;
	let t4_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].DOUGHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber(), 2) + "";
	let t4;
	let t5;
	let t6_value = /*pool*/ ctx[3].containing[0].symbol + "";
	let t6;
	let t7;
	let t8_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].WETHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber(), 2) + "";
	let t8;
	let t9;
	let t10_value = /*pool*/ ctx[3].containing[1].symbol + "";
	let t10;
	let t11;
	let t12_value = formatFiat((/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].DOUGHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber() * /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].DOUGHPrice + /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].WETHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber() * /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].ETHPrice).toFixed(2)) + "";
	let t12;

	return {
		c() {
			p = element("p");
			t0 = text("You are staking   : ");
			strong = element("strong");
			t1 = text(t1_value);
			t2 = text("%");
			t3 = text(" of the pool\n                          = [");
			t4 = text(t4_value);
			t5 = space();
			t6 = text(t6_value);
			t7 = text(", ");
			t8 = text(t8_value);
			t9 = space();
			t10 = text(t10_value);
			t11 = text("]\n                          = ");
			t12 = text(t12_value);
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, strong);
			append(strong, t1);
			append(strong, t2);
			append(p, t3);
			append(p, t4);
			append(p, t5);
			append(p, t6);
			append(p, t7);
			append(p, t8);
			append(p, t9);
			append(p, t10);
			append(p, t11);
			append(p, t12);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$balances, pool, $farming*/ 280 && t1_value !== (t1_value = toFixed(/*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance] * 100 / /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].totalStakedBPTAmount, 3) + "")) set_data(t1, t1_value);
			if (dirty[0] & /*$farming, pool, $balances*/ 280 && t4_value !== (t4_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].DOUGHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber(), 2) + "")) set_data(t4, t4_value);
			if (dirty[0] & /*pool*/ 8 && t6_value !== (t6_value = /*pool*/ ctx[3].containing[0].symbol + "")) set_data(t6, t6_value);
			if (dirty[0] & /*$farming, pool, $balances*/ 280 && t8_value !== (t8_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].WETHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber(), 2) + "")) set_data(t8, t8_value);
			if (dirty[0] & /*pool*/ 8 && t10_value !== (t10_value = /*pool*/ ctx[3].containing[1].symbol + "")) set_data(t10, t10_value);
			if (dirty[0] & /*$farming, pool, $balances*/ 280 && t12_value !== (t12_value = formatFiat((/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].DOUGHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber() * /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].DOUGHPrice + /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].WETHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber() * /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].ETHPrice).toFixed(2)) + "")) set_data(t12, t12_value);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (844:14) {#if pool.contractType === "Geyser"}
function create_if_block_11(ctx) {
	let br;
	let t0;
	let p0;
	let t1;
	let strong0;
	let t2_value = /*geyserApy*/ ctx[7].yourStake.toFixed(2) + "";
	let t2;
	let t3;
	let t4;
	let strong1;
	let t5_value = /*geyserApy*/ ctx[7].earnedOptimistic + "";
	let t5;
	let t6;
	let t7;
	let t8;
	let p1;
	let t9;
	let strong2;
	let t10_value = /*geyserApy*/ ctx[7].apy + "";
	let t10;
	let t11;
	let t12;
	let t13;
	let p2;
	let t14;
	let strong3;
	let t15_value = /*geyserApy*/ ctx[7].earnedNotOptimistic + "";
	let t15;
	let t16;
	let t17;
	let strong4;
	let t18_value = /*geyserApy*/ ctx[7].apyNotOptimistic + "";
	let t18;
	let t19;
	let t20;

	return {
		c() {
			br = element("br");
			t0 = space();
			p0 = element("p");
			t1 = text("Your stake of ");
			strong0 = element("strong");
			t2 = text(t2_value);
			t3 = text(" BPT");
			t4 = text(" is earning right now ");
			strong1 = element("strong");
			t5 = text(t5_value);
			t6 = text(" DOUGH");
			t7 = text(" assuming you will not unstake until the end of the program.");
			t8 = space();
			p1 = element("p");
			t9 = text("Approx ");
			strong2 = element("strong");
			t10 = text(t10_value);
			t11 = text("%");
			t12 = text(".");
			t13 = space();
			p2 = element("p");
			t14 = text("If you would unstake right now, you would get exactly ");
			strong3 = element("strong");
			t15 = text(t15_value);
			t16 = text(" DOUGH");
			t17 = text(", which is approx ");
			strong4 = element("strong");
			t18 = text(t18_value);
			t19 = text("% APR");
			t20 = text(".");
		},
		m(target, anchor) {
			insert(target, br, anchor);
			insert(target, t0, anchor);
			insert(target, p0, anchor);
			append(p0, t1);
			append(p0, strong0);
			append(strong0, t2);
			append(strong0, t3);
			append(p0, t4);
			append(p0, strong1);
			append(strong1, t5);
			append(strong1, t6);
			append(p0, t7);
			insert(target, t8, anchor);
			insert(target, p1, anchor);
			append(p1, t9);
			append(p1, strong2);
			append(strong2, t10);
			append(strong2, t11);
			append(p1, t12);
			insert(target, t13, anchor);
			insert(target, p2, anchor);
			append(p2, t14);
			append(p2, strong3);
			append(strong3, t15);
			append(strong3, t16);
			append(p2, t17);
			append(p2, strong4);
			append(strong4, t18);
			append(strong4, t19);
			append(p2, t20);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*geyserApy*/ 128 && t2_value !== (t2_value = /*geyserApy*/ ctx[7].yourStake.toFixed(2) + "")) set_data(t2, t2_value);
			if (dirty[0] & /*geyserApy*/ 128 && t5_value !== (t5_value = /*geyserApy*/ ctx[7].earnedOptimistic + "")) set_data(t5, t5_value);
			if (dirty[0] & /*geyserApy*/ 128 && t10_value !== (t10_value = /*geyserApy*/ ctx[7].apy + "")) set_data(t10, t10_value);
			if (dirty[0] & /*geyserApy*/ 128 && t15_value !== (t15_value = /*geyserApy*/ ctx[7].earnedNotOptimistic + "")) set_data(t15, t15_value);
			if (dirty[0] & /*geyserApy*/ 128 && t18_value !== (t18_value = /*geyserApy*/ ctx[7].apyNotOptimistic + "")) set_data(t18, t18_value);
		},
		d(detaching) {
			if (detaching) detach(br);
			if (detaching) detach(t0);
			if (detaching) detach(p0);
			if (detaching) detach(t8);
			if (detaching) detach(p1);
			if (detaching) detach(t13);
			if (detaching) detach(p2);
		}
	};
}

// (644:14) {:else}
function create_else_block_3(ctx) {
	let div4;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let a;
	let t1_value = /*ammPool*/ ctx[42].name + "";
	let t1;
	let a_href_value;
	let t2;
	let div1;
	let t3_value = /*ammPool*/ ctx[42].description + "";
	let t3;
	let t4;
	let div2;
	let t5_value = /*ammPool*/ ctx[42].weeklyRewards + "";
	let t5;
	let t6;
	let t7_value = /*ammPool*/ ctx[42].rewards_token + "";
	let t7;
	let t8;
	let div3;
	let t9_value = /*ammPool*/ ctx[42].platform + "";
	let t9;
	let t10;
	let t11;
	let t12;

	function select_block_type_4(ctx, dirty) {
		if (/*ammPool*/ ctx[42].contractType === "Geyser") return create_if_block_6;
		return create_else_block_5;
	}

	let current_block_type = select_block_type_4(ctx, [-1]);
	let if_block0 = current_block_type(ctx);

	function select_block_type_6(ctx, dirty) {
		if (/*ammPool*/ ctx[42].enabled) return create_if_block_5;
		return create_else_block_4;
	}

	let current_block_type_1 = select_block_type_6(ctx, [-1]);
	let if_block1 = current_block_type_1(ctx);

	return {
		c() {
			div4 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			a = element("a");
			t1 = text(t1_value);
			t2 = space();
			div1 = element("div");
			t3 = text(t3_value);
			t4 = space();
			div2 = element("div");
			t5 = text(t5_value);
			t6 = space();
			t7 = text(t7_value);
			t8 = space();
			div3 = element("div");
			t9 = text(t9_value);
			t10 = space();
			if_block0.c();
			t11 = space();
			if_block1.c();
			t12 = space();
			attr(img, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img.src !== (img_src_value = images.logos.piedao_clean)) attr(img, "src", img_src_value);
			attr(img, "alt", "PieDAO logo");
			attr(a, "href", a_href_value = /*ammPool*/ ctx[42].poolLink);
			attr(a, "target", "_blank");
			attr(div0, "class", "title text-lg");
			attr(div1, "class", "subtitle font-thin");
			attr(div2, "class", "apy");
			attr(div3, "class", "apy");
			attr(div4, "class", "farming-card flex flex-col justify-center align-center items-center text-center mx-2 my-2 md:m-2 border border-gray border-opacity-50 border-solid rounded-sm p-6");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, img);
			append(div4, t0);
			append(div4, div0);
			append(div0, a);
			append(a, t1);
			append(div4, t2);
			append(div4, div1);
			append(div1, t3);
			append(div4, t4);
			append(div4, div2);
			append(div2, t5);
			append(div2, t6);
			append(div2, t7);
			append(div4, t8);
			append(div4, div3);
			append(div3, t9);
			append(div4, t10);
			if_block0.m(div4, null);
			append(div4, t11);
			if_block1.m(div4, null);
			append(div4, t12);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*incentivizedPools*/ 64 && t1_value !== (t1_value = /*ammPool*/ ctx[42].name + "")) set_data(t1, t1_value);

			if (dirty[0] & /*incentivizedPools*/ 64 && a_href_value !== (a_href_value = /*ammPool*/ ctx[42].poolLink)) {
				attr(a, "href", a_href_value);
			}

			if (dirty[0] & /*incentivizedPools*/ 64 && t3_value !== (t3_value = /*ammPool*/ ctx[42].description + "")) set_data(t3, t3_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t5_value !== (t5_value = /*ammPool*/ ctx[42].weeklyRewards + "")) set_data(t5, t5_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t7_value !== (t7_value = /*ammPool*/ ctx[42].rewards_token + "")) set_data(t7, t7_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t9_value !== (t9_value = /*ammPool*/ ctx[42].platform + "")) set_data(t9, t9_value);

			if (current_block_type === (current_block_type = select_block_type_4(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div4, t11);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_6(ctx, dirty)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div4, t12);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(div4);
			if_block0.d();
			if_block1.d();
		}
	};
}

// (624:14) {#if ammPool.highlight }
function create_if_block_2(ctx) {
	let div5;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let a0;
	let t1_value = /*ammPool*/ ctx[42].name + "";
	let t1;
	let a0_href_value;
	let t2;
	let div1;
	let t3_value = /*ammPool*/ ctx[42].description + "";
	let t3;
	let t4;
	let div2;
	let t5_value = /*ammPool*/ ctx[42].weeklyRewards + "";
	let t5;
	let t6;
	let t7_value = /*ammPool*/ ctx[42].rewards_token + "";
	let t7;
	let t8;
	let div3;
	let a1;
	let t9_value = /*ammPool*/ ctx[42].platform + "";
	let t9;
	let a1_href_value;
	let t10;
	let div4;
	let t11;
	let t12;

	function select_block_type_2(ctx, dirty) {
		if (/*$farming*/ ctx[8][/*ammPool*/ ctx[42].addressUniPoll] !== undefined) return create_if_block_4;
		return create_else_block_2;
	}

	let current_block_type = select_block_type_2(ctx, [-1]);
	let if_block0 = current_block_type(ctx);

	function select_block_type_3(ctx, dirty) {
		if (/*ammPool*/ ctx[42].enabled) return create_if_block_3;
		return create_else_block_1;
	}

	let current_block_type_1 = select_block_type_3(ctx, [-1]);
	let if_block1 = current_block_type_1(ctx);

	return {
		c() {
			div5 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			a0 = element("a");
			t1 = text(t1_value);
			t2 = space();
			div1 = element("div");
			t3 = text(t3_value);
			t4 = space();
			div2 = element("div");
			t5 = text(t5_value);
			t6 = space();
			t7 = text(t7_value);
			t8 = space();
			div3 = element("div");
			a1 = element("a");
			t9 = text(t9_value);
			t10 = space();
			div4 = element("div");
			if_block0.c();
			t11 = space();
			if_block1.c();
			t12 = space();
			attr(img, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img.src !== (img_src_value = images.logos.piedao_clean)) attr(img, "src", img_src_value);
			attr(img, "alt", "PieDAO logo");
			attr(a0, "href", a0_href_value = /*ammPool*/ ctx[42].poolLink);
			attr(a0, "target", "_blank");
			attr(div0, "class", "title text-lg");
			attr(div1, "class", "subtitle font-thin");
			attr(div2, "class", "apy");
			attr(a1, "href", a1_href_value = /*ammPool*/ ctx[42].poolLink);
			attr(a1, "target", "_blank");
			attr(div3, "class", "apy");
			attr(div4, "class", "apy");
			attr(div5, "class", "highlight-box farming-card flex flex-col justify-center align-center items-center text-center mx-2 my-2 md:m-2 border border-gray border-opacity-50 border-solid rounded-sm p-6");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, img);
			append(div5, t0);
			append(div5, div0);
			append(div0, a0);
			append(a0, t1);
			append(div5, t2);
			append(div5, div1);
			append(div1, t3);
			append(div5, t4);
			append(div5, div2);
			append(div2, t5);
			append(div2, t6);
			append(div2, t7);
			append(div5, t8);
			append(div5, div3);
			append(div3, a1);
			append(a1, t9);
			append(div5, t10);
			append(div5, div4);
			if_block0.m(div4, null);
			append(div5, t11);
			if_block1.m(div5, null);
			append(div5, t12);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*incentivizedPools*/ 64 && t1_value !== (t1_value = /*ammPool*/ ctx[42].name + "")) set_data(t1, t1_value);

			if (dirty[0] & /*incentivizedPools*/ 64 && a0_href_value !== (a0_href_value = /*ammPool*/ ctx[42].poolLink)) {
				attr(a0, "href", a0_href_value);
			}

			if (dirty[0] & /*incentivizedPools*/ 64 && t3_value !== (t3_value = /*ammPool*/ ctx[42].description + "")) set_data(t3, t3_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t5_value !== (t5_value = /*ammPool*/ ctx[42].weeklyRewards + "")) set_data(t5, t5_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t7_value !== (t7_value = /*ammPool*/ ctx[42].rewards_token + "")) set_data(t7, t7_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t9_value !== (t9_value = /*ammPool*/ ctx[42].platform + "")) set_data(t9, t9_value);

			if (dirty[0] & /*incentivizedPools*/ 64 && a1_href_value !== (a1_href_value = /*ammPool*/ ctx[42].poolLink)) {
				attr(a1, "href", a1_href_value);
			}

			if (current_block_type === (current_block_type = select_block_type_2(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div4, null);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_3(ctx, dirty)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div5, t12);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(div5);
			if_block0.d();
			if_block1.d();
		}
	};
}

// (667:20) {:else}
function create_else_block_5(ctx) {
	let div;

	function select_block_type_5(ctx, dirty) {
		if (/*$farming*/ ctx[8][/*ammPool*/ ctx[42].addressUniPoll] !== undefined) return create_if_block_10;
		return create_else_block_6;
	}

	let current_block_type = select_block_type_5(ctx, [-1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "apy");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_5(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

// (652:20) {#if ammPool.contractType === 'Geyser'}
function create_if_block_6(ctx) {
	let div;
	let t1;
	let t2;
	let t3;
	let if_block2_anchor;
	let if_block0 = /*geyserApy*/ ctx[7].loaded === false && create_if_block_9(ctx);
	let if_block1 = /*geyserApy*/ ctx[7].loaded && /*geyserApy*/ ctx[7].yourStake > 0 && create_if_block_8(ctx);
	let if_block2 = /*geyserApy*/ ctx[7].loaded && /*geyserApy*/ ctx[7].yourStake == 0 && create_if_block_7(ctx);

	return {
		c() {
			div = element("div");
			div.innerHTML = `<a target="_blank" href="https://forum.piedao.org/t/pip-20-week-2-incentive-programs/197">ℹ️</a>`;
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
			set_style(div, "position", "absolute");
			set_style(div, "top", "10px");
			set_style(div, "right", "10px");
			attr(div, "class", "apy");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			insert(target, t1, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t3, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, if_block2_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*geyserApy*/ ctx[7].loaded === false) {
				if (if_block0) {
					
				} else {
					if_block0 = create_if_block_9(ctx);
					if_block0.c();
					if_block0.m(t2.parentNode, t2);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*geyserApy*/ ctx[7].loaded && /*geyserApy*/ ctx[7].yourStake > 0) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_8(ctx);
					if_block1.c();
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*geyserApy*/ ctx[7].loaded && /*geyserApy*/ ctx[7].yourStake == 0) {
				if (if_block2) {
					
				} else {
					if_block2 = create_if_block_7(ctx);
					if_block2.c();
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (detaching) detach(t1);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t3);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

// (671:24) {:else}
function create_else_block_6(ctx) {
	let t;

	return {
		c() {
			t = text("n/a");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (669:24) {#if $farming[ammPool.addressUniPoll] !== undefined}
function create_if_block_10(ctx) {
	let t_value = /*$farming*/ ctx[8][/*ammPool*/ ctx[42].addressUniPoll].apr + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$farming, incentivizedPools*/ 320 && t_value !== (t_value = /*$farming*/ ctx[8][/*ammPool*/ ctx[42].addressUniPoll].apr + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (655:22) {#if geyserApy.loaded === false}
function create_if_block_9(ctx) {
	let t;

	return {
		c() {
			t = text("Loading 🧘‍♀️");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (659:22) {#if geyserApy.loaded && geyserApy.yourStake > 0}
function create_if_block_8(ctx) {
	let div;
	let t0_value = /*geyserApy*/ ctx[7].apy + "";
	let t0;
	let t1;

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = text(" %");
			attr(div, "class", "apy");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*geyserApy*/ 128 && t0_value !== (t0_value = /*geyserApy*/ ctx[7].apy + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (663:22) {#if geyserApy.loaded && geyserApy.yourStake == 0}
function create_if_block_7(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.textContent = "You are not staking";
			attr(div, "class", "apy");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (679:20) {:else}
function create_else_block_4(ctx) {
	let button;

	return {
		c() {
			button = element("button");
			button.textContent = "Oct 3rd, 6:00pm UTC";
			button.disabled = true;
			attr(button, "class", "btn border-white clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
		}
	};
}

// (677:20) {#if ammPool.enabled}
function create_if_block_5(ctx) {
	let button;
	let mounted;
	let dispose;

	function click_handler_1(...args) {
		return /*click_handler_1*/ ctx[16](/*ammPool*/ ctx[42], ...args);
	}

	return {
		c() {
			button = element("button");
			button.textContent = "Select";
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (634:22) {:else}
function create_else_block_2(ctx) {
	let t;

	return {
		c() {
			t = text("n/a");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (632:22) {#if $farming[ammPool.addressUniPoll] !== undefined}
function create_if_block_4(ctx) {
	let t_value = /*$farming*/ ctx[8][/*ammPool*/ ctx[42].addressUniPoll].apr + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$farming, incentivizedPools*/ 320 && t_value !== (t_value = /*$farming*/ ctx[8][/*ammPool*/ ctx[42].addressUniPoll].apr + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (640:20) {:else}
function create_else_block_1(ctx) {
	let button;

	return {
		c() {
			button = element("button");
			button.textContent = "Oct 3rd, 6:00pm UTC";
			button.disabled = true;
			attr(button, "class", "btn border-white clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
		}
	};
}

// (638:20) {#if ammPool.enabled}
function create_if_block_3(ctx) {
	let button;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[15](/*ammPool*/ ctx[42], ...args);
	}

	return {
		c() {
			button = element("button");
			button.textContent = "Select";
			attr(button, "class", "btn border-white clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (623:12) {#each filter(incentivizedPools, { deprecated: false }) as ammPool}
function create_each_block_1(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*ammPool*/ ctx[42].highlight) return create_if_block_2;
		return create_else_block_3;
	}

	let current_block_type = select_block_type_1(ctx, [-1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (698:16) {:else}
function create_else_block(ctx) {
	let button;

	return {
		c() {
			button = element("button");
			button.textContent = "Oct 3rd, 6:00pm UTC";
			button.disabled = true;
			attr(button, "class", "btn border-white clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
		}
	};
}

// (696:16) {#if ammPool.enabled}
function create_if_block_1(ctx) {
	let button;
	let mounted;
	let dispose;

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[17](/*ammPool*/ ctx[42], ...args);
	}

	return {
		c() {
			button = element("button");
			button.textContent = "Select";
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_2);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (689:10) {#each filter(incentivizedPools, { deprecated: true }) as ammPool}
function create_each_block(ctx) {
	let div3;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let a;
	let t1_value = /*ammPool*/ ctx[42].name + "";
	let t1;
	let a_href_value;
	let t2;
	let div1;
	let t3_value = /*ammPool*/ ctx[42].description + "";
	let t3;
	let t4;
	let div2;
	let t5_value = /*ammPool*/ ctx[42].platform + "";
	let t5;
	let t6;
	let t7;

	function select_block_type_7(ctx, dirty) {
		if (/*ammPool*/ ctx[42].enabled) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type_7(ctx, [-1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div3 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			a = element("a");
			t1 = text(t1_value);
			t2 = space();
			div1 = element("div");
			t3 = text(t3_value);
			t4 = space();
			div2 = element("div");
			t5 = text(t5_value);
			t6 = space();
			if_block.c();
			t7 = space();
			attr(img, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img.src !== (img_src_value = images.logos.piedao_clean)) attr(img, "src", img_src_value);
			attr(img, "alt", "PieDAO logo");
			attr(a, "href", a_href_value = /*ammPool*/ ctx[42].poolLink);
			attr(a, "target", "_blank");
			attr(div0, "class", "title text-lg");
			attr(div1, "class", "subtitle font-thin");
			attr(div2, "class", "apy");
			attr(div3, "class", "farming-card flex flex-col justify-center align-center items-center text-center mx-2 my-2 md:m-2 border border-gray border-opacity-50 border-solid rounded-sm p-6");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, img);
			append(div3, t0);
			append(div3, div0);
			append(div0, a);
			append(a, t1);
			append(div3, t2);
			append(div3, div1);
			append(div1, t3);
			append(div3, t4);
			append(div3, div2);
			append(div2, t5);
			append(div3, t6);
			if_block.m(div3, null);
			append(div3, t7);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*incentivizedPools*/ 64 && t1_value !== (t1_value = /*ammPool*/ ctx[42].name + "")) set_data(t1, t1_value);

			if (dirty[0] & /*incentivizedPools*/ 64 && a_href_value !== (a_href_value = /*ammPool*/ ctx[42].poolLink)) {
				attr(a, "href", a_href_value);
			}

			if (dirty[0] & /*incentivizedPools*/ 64 && t3_value !== (t3_value = /*ammPool*/ ctx[42].description + "")) set_data(t3, t3_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t5_value !== (t5_value = /*ammPool*/ ctx[42].platform + "")) set_data(t5, t5_value);

			if (current_block_type === (current_block_type = select_block_type_7(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div3, t7);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(div3);
			if_block.d();
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let img0;
	let img0_src_value;
	let t0;
	let img1;
	let img1_src_value;
	let t1;
	let div0;

	function select_block_type(ctx, dirty) {
		if (!/*pool*/ ctx[3]) return create_if_block;
		return create_else_block_7;
	}

	let current_block_type = select_block_type(ctx, [-1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div1 = element("div");
			img0 = element("img");
			t0 = space();
			img1 = element("img");
			t1 = space();
			div0 = element("div");
			if_block.c();
			attr(img0, "class", "banner-desktop");
			if (img0.src !== (img0_src_value = "https://raw.githubusercontent.com/pie-dao/brand/master/misc/amazingrewards4.png")) attr(img0, "src", img0_src_value);
			attr(img1, "class", "banner-mobile");
			if (img1.src !== (img1_src_value = "https://raw.githubusercontent.com/pie-dao/brand/master/misc/amazingrewards4-mobile.png")) attr(img1, "src", img1_src_value);
			attr(div0, "class", "liquidity-container flex flex-col align-center bg-grey-243 rounded-4px p-4 my-0 md:p-6 w-full");
			attr(div1, "class", "content flex flex-col");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, img0);
			append(div1, t0);
			append(div1, img1);
			append(div1, t1);
			append(div1, div0);
			if_block.m(div0, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div0, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			if_block.d();
		}
	};
}

let ethBalance = 0;

function instance($$self, $$props, $$invalidate) {
	let $balances;
	let $currentRoute;
	let $allowances;
	let $eth;
	let $farming;
	let $_;
	component_subscribe($$self, balances, $$value => $$invalidate(4, $balances = $$value));
	component_subscribe($$self, currentRoute, $$value => $$invalidate(33, $currentRoute = $$value));
	component_subscribe($$self, allowances, $$value => $$invalidate(34, $allowances = $$value));
	component_subscribe($$self, eth, $$value => $$invalidate(36, $eth = $$value));
	component_subscribe($$self, farming, $$value => $$invalidate(8, $farming = $$value));
	component_subscribe($$self, _, $$value => $$invalidate(9, $_ = $$value));
	const isAddress = thing => thing && ethers.utils.isHexString(thing) && thing.length === 42;
	let ethKey;
	let intiated = false;
	let amountToStake = 0;
	let amountToUnstake = 0;
	let isReady = false;
	const referral = $currentRoute.params.referral || window.localStorage.getItem("referral");

	const estimateUnstake = async () => {
		const { provider, signer } = get(eth);
		let contract = new ethers.Contract("0xb3c2b0056627cc1dc148d8fc29f5abdf4dd837bc", geyserABI, provider);
		let overrides = { from: $eth.address };
		let data = await contract.callStatic.updateAccounting(overrides);
		let loaded = false;
		let _totalStakingShareSeconds = data[3];
		let stakingShareSeconds = data[2];
		let totalUnlocked = data[1];
		let _pool = incentivizedPools[2];
		let apy8Wweeks = 0;
		let apy = 0;
		let rewardsPerBPT = 0;
		let $RewardsPerBPT = 0;
		let days60APY = 0;
		let apyV2 = 0;
		let apyV2NotOptimistic = 0;
		let yourStake = 0;
		let seconds = BigNumber(0);
		let rewardPerSecond = 0;
		let rewardPerWeek = 0;
		let rewardPer8Week = 0;
		let unstakeNowRewards = 0;
		let totalUserRewards = totalUnlocked.mul(stakingShareSeconds).div(_totalStakingShareSeconds);
		let earnedOptimistic = BigNumber(totalUserRewards.toString()).dividedBy(10 ** 18);
		let tokenStakedPrice = 0;
		let DOUGHPrice = 0;
		let BPTPrice = 0;

		if ($balances[_pool.KeyUnipoolBalance] && $farming[_pool.addressUniPoll] !== undefined) {
			DOUGHPrice = $farming[incentivizedPools[0].addressUniPoll] && $farming[incentivizedPools[0].addressUniPoll].DOUGHPrice
			? $farming[incentivizedPools[0].addressUniPoll].DOUGHPrice
			: 0;

			BPTPrice = $farming[_pool.addressUniPoll].BPTPrice || 0;
			tokenStakedPrice = $farming[_pool.addressUniPoll].DOUGHPrice || 0;
			const amount = ethers.BigNumber.from(BigNumber($balances[_pool.KeyUnipoolBalance].toString()).multipliedBy(10 ** 18).toFixed(0));
			unstakeNowRewards = await contract.callStatic.unstakeQuery(amount, overrides);
			unstakeNowRewards = BigNumber(unstakeNowRewards.toString()).dividedBy(10 ** 18).toNumber();
			seconds = BigNumber(stakingShareSeconds.toString()).dividedBy(BigNumber($balances[_pool.KeyUnipoolBalance].toString()).multipliedBy(10 ** 18)).dividedBy(1000).dividedBy(1000);
			yourStake = $balances[_pool.KeyUnipoolBalance].toNumber();
			rewardsPerBPT = earnedOptimistic.toNumber() / yourStake;
			$RewardsPerBPT = rewardsPerBPT * DOUGHPrice;
			let rewardsPerBPTNotOptimistic = unstakeNowRewards / yourStake;
			let $RewardsPerBPTNotOptimistic = rewardsPerBPTNotOptimistic * DOUGHPrice;
			let days60APYNotOptimistic = $RewardsPerBPTNotOptimistic * 100 / BPTPrice;
			days60APY = $RewardsPerBPT * 100 / BPTPrice;
			apyV2 = days60APY * (31536000 / seconds.toNumber());
			apyV2NotOptimistic = days60APYNotOptimistic * (31536000 / seconds.toNumber());
			loaded = true;
		}

		$$invalidate(7, geyserApy = {
			BPTPrice,
			rewardsPerBPT,
			DOUGHPrice,
			seconds: seconds.toNumber(),
			earnedOptimistic: earnedOptimistic.toFixed(4),
			earnedNotOptimistic: unstakeNowRewards.toFixed(4),
			yourStake,
			apy: apyV2.toFixed(2),
			apyNotOptimistic: apyV2NotOptimistic.toFixed(2),
			totalStakingShareSeconds: _totalStakingShareSeconds.toString(),
			stakingShareSeconds: stakingShareSeconds.toString(),
			totalUnlocked: totalUnlocked.toString(),
			totalUserRewards: earnedOptimistic.toString(),
			$RewardsPerBPT,
			loaded
		});

		console.log("geyserApy", geyserApy);
		return earnedOptimistic;
	};

	window.addEventListener(
		"price-update",
		async function (e) {
			console.log("price-update", e);
			$$invalidate(32, isReady = true);

			incentivizedPools.forEach(async pool => {
				if (pool.type === "UniswapV2") {
					await calculateAPRUniswap(pool.addressUniPoll, pool.addressTokenToStake, null, null, pool.containing[0].address, pool.containing[1].address);
				} else {
					await calculateAPRBalancer(pool.addressUniPoll, pool.addressTokenToStake, null, null, pool.containing[0].address, pool.containing[1].address);
				}
			});

			await estimateUnstake();
		},
		false
	);

	const needApproval = (pool, allowance) => {
		if (allowance.isEqualTo(0)) return true;
		if (allowance.isGreaterThanOrEqualTo(BigNumber(amountToStake))) return false;
	};

	const action = async (pool, actionType) => {
		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		const { addressTokenToStake, addressUniPoll } = pool;

		if (actionType === "unlock") {
			await approveMax(addressTokenToStake, addressUniPoll);
			$$invalidate(5, needAllowance = false);
		}
	};

	const unstake = async () => {
		if (amountToUnstake === 0) {
			displayNotification({ message: "Amount is zero", type: "hint" });
			return;
		}

		let requestedAmount = BigNumber(amountToUnstake);
		const max = $balances[pool.KeyUnipoolBalance];

		if (requestedAmount.isGreaterThan(max)) {
			requestedAmount = max;
			$$invalidate(1, amountToUnstake = max.toNumber());

			displayNotification({
				message: "Amount set to max",
				type: "hint"
			});
		}

		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		let unipool;
		let emitterToUse;
		const amountWei = requestedAmount.multipliedBy(10 ** 18).toFixed(0);

		if (pool.contractType === "UniPool") {
			unipool = await contract({
				address: pool.addressUniPoll,
				abi: recipeUnipool
			});

			const { emitter } = displayNotification(await unipool.withdraw(amountWei));
			emitterToUse = emitter;
		} else {
			unipool = await contract({
				address: pool.addressUniPoll,
				abi: geyserABI
			});

			const { emitter } = displayNotification(await unipool.unstake(amountWei, 0));
			emitterToUse = emitter;
		}

		emitterToUse.on("txConfirmed", ({ hash }) => {
			const { dismiss } = displayNotification({
				message: "Confirming...",
				type: "pending"
			});

			const subscription = subject("blockNumber").subscribe({
				next: () => {
					displayNotification({
						autoDismiss: 15000,
						message: `${requestedAmount.toFixed()} unstaked successfully`,
						type: "success"
					});

					dismiss();
					subscription.unsubscribe();
				}
			});

			return {
				autoDismiss: 1,
				message: "Mined",
				type: "success"
			};
		});
	};

	const exit = async () => {
		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		const unipool = await contract({
			address: pool.addressUniPoll,
			abi: recipeUnipool
		});

		const { emitter } = displayNotification(await unipool.exit());

		emitter.on("txConfirmed", ({ hash }) => {
			const { dismiss } = displayNotification({
				message: "Confirming...",
				type: "pending"
			});

			const subscription = subject("blockNumber").subscribe({
				next: () => {
					displayNotification({
						autoDismiss: 15000,
						message: `You claimed and unstaked`,
						type: "success"
					});

					dismiss();
					subscription.unsubscribe();
				}
			});

			return {
				autoDismiss: 1,
				message: "Mined",
				type: "success"
			};
		});
	};

	const stake = async () => {
		if (amountToStake === 0) {
			displayNotification({ message: "Amount it zero", type: "hint" });
			return;
		}

		let requestedAmount = BigNumber(amountToStake);
		const max = $balances[pool.KeyAddressTokenToStake];
		let referralValidated = "0x4efD8CEad66bb0fA64C8d53eBE65f31663199C6d"; //Agent address

		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		if (requestedAmount.isGreaterThan(max)) {
			requestedAmount = max;
			$$invalidate(0, amountToStake = max.toNumber());

			displayNotification({
				message: "Amount set to max",
				type: "hint"
			});
		}

		if (referral && isAddress(referral) && referral.toLowerCase() !== $eth.address.toLowerCase()) {
			console.log("Im setting the referral to " + referral);
			referralValidated = referral;
		}

		const amountWei = requestedAmount.multipliedBy(10 ** 18).toFixed(0);
		let unipool;
		let emitterToUse;

		if (pool.contractType === "UniPool") {
			unipool = await contract({
				address: pool.addressUniPoll,
				abi: recipeUnipool
			});

			console.log(`Staking ${amountToStake} ${pool.toStakeSymbol} with referral ${referralValidated}`);
			const { emitter } = displayNotification(await unipool["stake(uint256,address)"](amountWei, referralValidated));
			emitterToUse = emitter;
		} else {
			unipool = await contract({
				address: pool.addressUniPoll,
				abi: geyserABI
			});

			const { emitter } = displayNotification(await unipool["stake(uint256)"](amountWei));
			emitterToUse = emitter;
		}

		emitterToUse.on("txConfirmed", ({ hash }) => {
			const { dismiss } = displayNotification({
				message: "Confirming...",
				type: "pending"
			});

			const subscription = subject("blockNumber").subscribe({
				next: () => {
					displayNotification({
						autoDismiss: 15000,
						message: `${requestedAmount.toFixed()} staked successfully`,
						type: "success"
					});

					dismiss();
					subscription.unsubscribe();
				}
			});

			return {
				autoDismiss: 1,
				message: "Mined",
				type: "success"
			};
		});
	};

	const getRewards = async () => {
		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		const unipool = await contract({
			address: pool.addressUniPoll,
			abi: recipeUnipool
		});

		const { emitter } = displayNotification(await unipool.getReward());

		emitter.on("txConfirmed", ({ hash }) => {
			const { dismiss } = displayNotification({
				message: "Confirming...",
				type: "pending"
			});

			const subscription = subject("blockNumber").subscribe({
				next: () => {
					displayNotification({
						autoDismiss: 15000,
						message: `${requestedAmount.toFixed()} staked successfully`,
						type: "success"
					});

					dismiss();
					subscription.unsubscribe();
				}
			});

			return {
				autoDismiss: 1,
				message: "Mined",
				type: "success"
			};
		});
	};

	const click_handler = ammPool => $$invalidate(3, pool = ammPool);
	const click_handler_1 = ammPool => $$invalidate(3, pool = ammPool);
	const click_handler_2 = ammPool => $$invalidate(3, pool = ammPool);
	const click_handler_3 = () => $$invalidate(3, pool = null);
	const click_handler_4 = () => exit();

	function input0_input_handler() {
		amountToUnstake = this.value;
		$$invalidate(1, amountToUnstake);
	}

	const click_handler_5 = () => {
		if ($balances[pool.KeyUnipoolBalance]) {
			$$invalidate(1, amountToUnstake = $balances[pool.KeyUnipoolBalance]);
		} else {
			$$invalidate(1, amountToUnstake = 0);
		}
	};

	const click_handler_6 = () => unstake();

	function input1_input_handler() {
		amountToStake = this.value;
		$$invalidate(0, amountToStake);
	}

	const click_handler_7 = () => {
		if ($balances[pool.KeyAddressTokenToStake]) {
			$$invalidate(0, amountToStake = $balances[pool.KeyAddressTokenToStake]);
		} else {
			$$invalidate(0, amountToStake = 0);
		}
	};

	const click_handler_8 = () => action(pool, "unlock");
	const click_handler_9 = () => stake();

	function input_input_handler() {
		amountToClaim = this.value;
		(($$invalidate(2, amountToClaim), $$invalidate(3, pool)), $$invalidate(4, $balances));
	}

	const click_handler_10 = () => {
		if ($balances[pool.KeyUnipoolEarnedBalance]) {
			$$invalidate(2, amountToClaim = $balances[pool.KeyUnipoolEarnedBalance].toFixed(4, BigNumber.ROUND_DOWN));
		} else {
			$$invalidate(2, amountToClaim = 0);
		}
	};

	const click_handler_11 = () => getRewards();

	function input_input_handler_1() {
		geyserApy.earnedOptimistic = this.value;
		$$invalidate(7, geyserApy);
	}

	let amountToClaim;
	let needAllowance;
	let incentivizedPools;
	let pool;
	let geyserEarned;
	let geyserApy;

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*pool, $balances*/ 24) {
			$: $$invalidate(2, amountToClaim = pool && $balances[pool.KeyUnipoolEarnedBalance]
			? $balances[pool.KeyUnipoolEarnedBalance]
			: "0.00000000");
		}

		if ($$self.$$.dirty[0] & /*pool*/ 8 | $$self.$$.dirty[1] & /*$allowances*/ 8) {
			$: {
				if (pool) $$invalidate(5, needAllowance = needApproval(pool, $allowances[pool.allowanceKey] || BigNumber(0)));
			}
		}

		if ($$self.$$.dirty[0] & /*incentivizedPools*/ 64 | $$self.$$.dirty[1] & /*$eth, isReady, intiated*/ 35) {
			$: if ($eth.address) {
				if (isReady) {
					incentivizedPools.forEach(async pool => {
						if (pool.type === "UniswapV2") {
							await calculateAPRUniswap(pool.addressUniPoll, pool.addressTokenToStake, null, null, pool.containing[0].address, pool.containing[1].address);
						}

						if (pool.type === "Balancer" && pool.contractType === "UniPool") {
							await calculateAPRBalancer(pool.addressUniPoll, pool.addressTokenToStake, null, null, pool.containing[0].address, pool.containing[1].address);
						}

						if (pool.type === "Balancer" && pool.contractType === "Geyser") {
							await calculateAPRBalancer(pool.addressUniPoll, pool.addressTokenToStake, null, null, pool.containing[0].address, pool.containing[1].address);
							await estimateUnstake();
						}
					});
				}

				if (!intiated) {
					const address = $eth.address;

					incentivizedPools.forEach(async p => {
						try {
							calculateAPRBalancer();
							subscribeToBalance(p.addressTokenToStake, address, true);
							subscribeToStaking(p.addressUniPoll, address, true);
							subscribeToAllowance(p.addressTokenToStake, address, p.addressUniPoll);
							p.allowanceKey = functionKey(p.addressTokenToStake, "allowance", [address, p.addressUniPoll]);
							p.KeyAddressTokenToStake = balanceKey(p.addressTokenToStake, address);

							if (p.contractType === "UniPool") {
								subscribeToStakingEarnings(p.addressUniPoll, address, true);
								p.KeyUnipoolBalance = balanceKey(p.addressUniPoll, address);
								p.KeyUnipoolEarnedBalance = balanceKey(p.addressUniPoll, address, ".earned");
							} else {
								console.log("Getting staked balance from geyser");
								console.log(p.addressUniPoll, "address");
								subscribeToStakingEarningsGeyser(p.addressUniPoll, address, true);
								p.KeyUnipoolBalance = balanceKey(p.addressUniPoll, address);
								await estimateUnstake();
							}
						} catch(e) {
							console.log(e);
						}
					});

					$$invalidate(31, intiated = true);
					bumpLifecycle();
				}
			}
		}
	};

	$: $$invalidate(3, pool = null);
	$: $$invalidate(5, needAllowance = true);

	$: $$invalidate(6, incentivizedPools = [
		{
			addressTokenToStake: "0xFAE2809935233d4BfE8a56c2355c4A2e7d1fFf1A",
			addressUniPoll: "0x8314337d2b13e1A61EadF0FD1686b2134D43762F",
			aprEnabled: true,
			deprecated: false,
			poolLink: "https://pools.balancer.exchange/#/pool/0xfae2809935233d4bfe8a56c2355c4a2e7d1fff1a/",
			name: "DOUGH / ETH",
			platform: "⚖️ Balancer",
			description: "WEEKLY REWARDS",
			rewards_token: "DOUGH",
			weeklyRewards: formatFiat(110000, ",", ".", ""),
			apy: 1.8,
			toStakeSymbol: "BPT",
			toStakeDesc: "Balancer: DOUGH/ETH 80/20",
			allowance: 0,
			type: "Balancer",
			contractType: "UniPool",
			containing: [
				{
					symbol: "DOUGH",
					address: "0xad32A8e6220741182940c5aBF610bDE99E737b2D",
					balance: "0",
					icon: getTokenImage("0xad32A8e6220741182940c5aBF610bDE99E737b2D")
				},
				{
					symbol: "ETH",
					address: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
					balance: "0",
					icon: getTokenImage("eth")
				}
			],
			allowanceKey: "",
			highlight: true,
			needAllowance: true,
			enabled: true
		},
		{
			addressTokenToStake: "0x35333CF3Db8e334384EC6D2ea446DA6e445701dF",
			aprEnabled: true,
			deprecated: false,
			addressUniPoll: "0x220f25C2105a65425913FE0CF38e7699E3992B97",
			poolLink: "https://pools.balancer.exchange/#/pool/0x35333cf3db8e334384ec6d2ea446da6e445701df/",
			name: "DEFI+S / ETH",
			type: "Balancer",
			contractType: "UniPool",
			containing: [
				{
					symbol: "DEFI+S",
					address: "0xad6a626ae2b43dcb1b39430ce496d2fa0365ba9c",
					balance: "0",
					icon: getTokenImage("0xad6a626ae2b43dcb1b39430ce496d2fa0365ba9c")
				},
				{
					symbol: "ETH",
					address: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
					balance: "0",
					icon: getTokenImage("eth")
				}
			],
			rewards_token: "DOUGH",
			toStakeSymbol: "BPT",
			toStakeDesc: "Balancer: DEFI+S/ETH 70/30",
			platform: "⚖️ Balancer",
			description: "WEEKLY REWARDS",
			weeklyRewards: formatFiat(20000, ",", ".", ""),
			apy: 1.8,
			allowance: 0,
			allowanceKey: "",
			needAllowance: true,
			enabled: true
		},
		{
			addressTokenToStake: "0xa795600590a7da0057469049ab8f1284baed977e",
			aprEnabled: false,
			deprecated: false,
			addressUniPoll: "0xb3c2b0056627cc1dc148d8fc29f5abdf4dd837bc",
			poolLink: "https://pools.balancer.exchange/#/pool/0xa795600590a7da0057469049ab8f1284baed977e/",
			name: "DEFI+L/ETH",
			type: "Balancer",
			contractType: "Geyser",
			containing: [
				{
					symbol: "DEFI+L",
					address: "0x78f225869c08d478c34e5f645d07a87d3fe8eb78",
					balance: "0",
					icon: getTokenImage("0x78f225869c08d478c34e5f645d07a87d3fe8eb78")
				},
				{
					symbol: "ETH",
					address: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
					balance: "0",
					icon: getTokenImage("eth")
				}
			],
			rewards_token: "DOUGH",
			toStakeSymbol: "BPT",
			toStakeDesc: "Balancer: DEFI+L/ETH 70/30",
			platform: "⚖️ Balancer",
			description: "WEEKLY REWARDS",
			weeklyRewards: formatFiat(20000, ",", ".", ""),
			apy: 1.8,
			allowance: 0,
			allowanceKey: "",
			needAllowance: true,
			enabled: true
		},
		{
			addressTokenToStake: "0x7aeFaF3ea1b465dd01561B0548c9FD969e3F76BA",
			aprEnabled: true,
			deprecated: true,
			addressUniPoll: "0x64964cb69f40A1B56AF76e32Eb5BF2e2E52a747c",
			name: "DEFI+S / DAI",
			poolLink: "https://app.uniswap.org/#/add/0x6B175474E89094C44Da98b954EedeAC495271d0F/0xaD6A626aE2B43DCb1B39430Ce496d2FA0365BA9C",
			platform: "🦄 Uniswap",
			contractType: "UniPool",
			containing: [
				{
					symbol: "DEFI+S",
					address: "0xad6a626ae2b43dcb1b39430ce496d2fa0365ba9c",
					balance: "0",
					icon: getTokenImage("0xad6a626ae2b43dcb1b39430ce496d2fa0365ba9c")
				},
				{
					symbol: "DAI",
					address: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
					balance: "0",
					icon: getTokenImage("0x6B175474E89094C44Da98b954EedeAC495271d0F")
				}
			],
			type: "UniswapV2",
			toStakeDesc: "Uniswap: DEFI+S/DAI 50/50",
			toStakeSymbol: "LP",
			description: "DEPRECATED POOL",
			rewards_token: "DOUGH",
			weeklyRewards: formatFiat(25000, ",", ".", ""),
			apy: 1.8,
			allowance: 0,
			allowanceKey: "",
			needAllowance: true,
			enabled: true
		}
	]);

	$: geyserEarned = BigNumber(0);
	$: $$invalidate(7, geyserApy = { apy: 0, loaded: false });

	return [
		amountToStake,
		amountToUnstake,
		amountToClaim,
		pool,
		$balances,
		needAllowance,
		incentivizedPools,
		geyserApy,
		$farming,
		$_,
		action,
		unstake,
		exit,
		stake,
		getRewards,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		input0_input_handler,
		click_handler_5,
		click_handler_6,
		input1_input_handler,
		click_handler_7,
		click_handler_8,
		click_handler_9,
		input_input_handler,
		click_handler_10,
		click_handler_11,
		input_input_handler_1
	];
}

class LPStaking extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {}, [-1, -1]);
	}
}

export default LPStaking;